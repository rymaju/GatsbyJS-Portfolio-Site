---
title: What I Learned Making an Online Code Editor
date: 2020-04-03
---

Fundamentals of Computer Science 2, shortened to Fundies 2, is the second introductory computer science class at Northeastern. The class is great, I love the ideas in the course and how much novel content there is for students of all levels. However, one thing I really hated about the course was how annoying it was to share code. A key tenet of the course is that you learn better through pair programming: coding with a partner who can add another perspective to the code you’re writing. I know from personal experience how nice it is to have someone to add fresh ideas when you’re worn down, or simply catch some syntax or logical errors you missed while coding. Pair programming worked well when you were both sitting together working on one computer, but because of the coronavirus pandemic, we had to turn to other sources for help. Git, VSCode Live Share, and just simply emailing files were ok, but you still had to spent 3 minutes changing configurations or setting up Code Runner to use the tester library. I set out to create a “plug-and-play” solution that just worked without any configuration.

So I built [fundiescollab.com](https://www.fundiescollab.com), a fullstack app that serves as an online code editor using the Fundies 2 tester library. I used Express with socket.io and Redis for the backend, and Vue with Microsoft’s Monaco Editor for the frontend. It took a lot of work, but it was such an amazing experience in fullstack web development.

Even though I had never built anything of this scale before, I felt confident from my experience building MERN apps. This app was a little different though. There wasn’t really a traditional CRUD style operation with well defined schemas, just a loose idea of saving and loading code. The most perplexing part of the project was the idea of “real time collaboration”. I had no idea how to do real time collaboration. But after some searching around, I found this package called socket.io which was designed just for real time connection.
Socket.io is a package that allows clients to stay connected to the server through an idea of a “socket”, essentially the client intermittently “polls” to check for events and stay connected. Meanwhile, it can also emit events to the server, which can then be broadcasted to all users connected to the same “room”. Sounds like exactly what I needed to have real time code collaboration! Users would join a room to start coding, and could share that link to invite others to the same room. At the same time, on every new character the new code would be sent up to the server and broadcast such that everybody’s code would be synced in real time. Crazy right? But socket.io uses familiar callback style syntax and pretty clear documentation that makes this stuff easy. It was a breeze to set up, and what I thought would be the hardest part of the project turned out to be trivial.

I also realized that users would probably want to be able to come back to the same room to continue where they left off. I would need some kind of persistent storage, like a database. But the database would update every time the code was updated! You need to keep everything updated in real time in order to broadcast the “saved code” to new users joining the room. A lot of databases would have worked here, but I felt like Redis was the best fit. Redis was useful for two key reasons: it was lighting fast due to the fact that it behaved like an in-memory cache, and also it could easily expire keys. Before Redis, I tried to set up cronjobs to clean up old rooms that expired, but Redis really helped to abstract a lot of that code, and make the backend logic a lot simpler.

Of course, I had to actually host this website, but my go-to hosting site, Heroku, wouldn’t work this time. Heroku doesn’t just let anybody read and write files on their filesystem, and so actually compiling and running Java code was impossible. I would need for flexibility, and for that I needed a real virtual private server. A VPS is essentially just a virtual machine that is allocated to you by some big company. Your server is one of hundreds of thousands that run concurrently in the dark in some hot data warehouse in some crusty corner of California. It was a pain to setup, but with DigitalOcean I got one going for only \$5 a month. The CPU and memory were alright, it was only a pain sometimes. For example, trying to build my Vue frontend on the VPS would just overload the 1GB of RAM allocated to me. But other than that inconvenience everything ran really well. The actual Express server and Redis apps barely took any RAM, maybe less than 80mb. If I were to do it again, I might have chosen AWS’s free tier, but I think that DigitalOcean was an interesting experiment that allowed me to learn a lot about Apache, Linux, and just a general understanding of how deployment works.

Another challenge was how to deal with security issues. Giving users the ability to submit any Java code they wanted was a huge risk. I needed to ensure that there would be no RCE (Remote Code Execution). Initially I naively thought that sanitizing the submitted code would be safe enough. It wasn’t. Thanks to the generous help of a high school friend, I found out that it was extremely trivial to run commands remotely on my virtual private server. The solution to this mess was not to double down on sanitizing the code, but to isolate and containerize the code entirely. Docker, usually used for containerizing applications to have a consistent runtime environment, was actually a perfect fit here. I was essentially using docker like a lightweight virtual machine. I booted it up with a Java image and let the code go wild. Docker shielded my application from anything malicious the user sent with their code. I had no idea what kind of feral animal the user had sent, but I knew that in the worst-case it would only destroy the container I put in it, and the real server would be intact. Either way, the container would either error and die, or spit back an answer I could actually use like a Java error or the output from stdout.

And with that all the complicated logic for my backend was complete, all I needed to do was write up the frontend in Vue and ship it. I chose Monaco Editor (the same editor that VSCode uses) because of how familiar it would be and how nice the intellisense is. I had some problems with Vue Monaco double packaging the Monaco source, and thus doubling the bundle size, but I managed to manually link up the packages, saving 5mb of uncompressed size. Despite that, the bundle size for [fundiescollab.com](https://www.fundiescollab.com) is huge! Its about 5mb, which is crazy on bad connections but not bad when compared to sites like LeetCode that also use pretty feature rich code editors. I think that if I were to do it again, I might just write my own Monaco Editor Vue library, or even try to heavily customize another less intensive code editor like CodeMirror in order to try to reduce bundle size.

All in all, this project was a really fun way for me to get more experience with fullstack web app development. I had so much fun chugging through the asynchronous functions, researching solutions to the challenges I was facing, and messing around with the frontend to make the website look perfect. I loved writing code by myself, without the help of a tutorial. I felt in control, and felt actual ownership of what I created. I would totally recommend anybody reading this to start up your own fullstack project, even if its something small, and just try your best to hack through it without a guide.
The next steps of my project will be to add incremental fixes and updates to improve some of the features, adding more intellisense, and maybe adding more security to rooms. With that said, [fundiescollab.com](https://www.fundiescollab.com) is 100% open source, so go to [github.com/rymaju/fundiescollab](https://www.github.com/rymaju/fundiescollab) to take a look at the code or contribute!
